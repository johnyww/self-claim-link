"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/sqlite";
exports.ids = ["vendor-chunks/sqlite"];
exports.modules = {

/***/ "(rsc)/./node_modules/sqlite/build/Database.js":
/*!***********************************************!*\
  !*** ./node_modules/sqlite/build/Database.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Database = void 0;\nconst Statement_1 = __webpack_require__(/*! ./Statement */ \"(rsc)/./node_modules/sqlite/build/Statement.js\");\nconst migrate_1 = __webpack_require__(/*! ./utils/migrate */ \"(rsc)/./node_modules/sqlite/build/utils/migrate.js\");\nconst strings_1 = __webpack_require__(/*! ./utils/strings */ \"(rsc)/./node_modules/sqlite/build/utils/strings.js\");\nconst format_error_1 = __webpack_require__(/*! ./utils/format-error */ \"(rsc)/./node_modules/sqlite/build/utils/format-error.js\");\n/**\n * Promisified wrapper for the sqlite3#Database interface.\n */\nclass Database {\n    constructor(config) {\n        this.config = config;\n        this.db = null;\n    }\n    /**\n     * Event handler when verbose mode is enabled.\n     * @see https://github.com/mapbox/node-sqlite3/wiki/Debugging\n     */\n    on(event, listener) {\n        this.db.on(event, listener);\n    }\n    /**\n     * Returns the underlying sqlite3 Database instance\n     */\n    getDatabaseInstance() {\n        return this.db;\n    }\n    /**\n     * Opens the database\n     */\n    open() {\n        return new Promise((resolve, reject) => {\n            let { filename, mode, driver } = this.config;\n            // https://github.com/mapbox/node-sqlite3/wiki/API#new-sqlite3databasefilename-mode-callback\n            if (filename === null || filename === undefined) {\n                throw new Error('sqlite: filename cannot be null / undefined');\n            }\n            if (!driver) {\n                throw new Error('sqlite: driver is not defined');\n            }\n            if (mode) {\n                this.db = new driver(filename, mode, err => {\n                    if (err) {\n                        return reject((0, format_error_1.formatError)(err));\n                    }\n                    resolve();\n                });\n            }\n            else {\n                this.db = new driver(filename, err => {\n                    if (err) {\n                        return reject((0, format_error_1.formatError)(err));\n                    }\n                    resolve();\n                });\n            }\n        });\n    }\n    /**\n     * Closes the database.\n     */\n    close() {\n        return new Promise((resolve, reject) => {\n            this.db.close(err => {\n                if (err) {\n                    return reject((0, format_error_1.formatError)(err));\n                }\n                resolve();\n            });\n        });\n    }\n    /**\n     * @see https://github.com/mapbox/node-sqlite3/wiki/API#databaseconfigureoption-value\n     */\n    configure(option, value) {\n        this.db.configure(option, value);\n    }\n    /**\n     * Runs the SQL query with the specified parameters. It does not retrieve any result data.\n     * The function returns the Database object for which it was called to allow for function chaining.\n     *\n     * @param {string} sql The SQL query to run.\n     *\n     * @param {any} [params, ...] When the SQL statement contains placeholders, you\n     * can pass them in here. They will be bound to the statement before it is\n     * executed. There are three ways of passing bind parameters: directly in\n     * the function's arguments, as an array, and as an object for named\n     * parameters. This automatically sanitizes inputs.\n     *\n     * @see https://github.com/mapbox/node-sqlite3/wiki/API#databaserunsql-param--callback\n     */\n    run(sql, ...params) {\n        return new Promise((resolve, reject) => {\n            const sqlObj = (0, strings_1.toSqlParams)(sql, params);\n            this.db.run(sqlObj.sql, ...sqlObj.params, function (err) {\n                if (err) {\n                    return reject((0, format_error_1.formatError)(err));\n                }\n                resolve({\n                    stmt: new Statement_1.Statement(this.stmt),\n                    lastID: this.lastID,\n                    changes: this.changes\n                });\n            });\n        });\n    }\n    /**\n     * Runs the SQL query with the specified parameters and resolves with\n     * with the first result row afterwards. If the result set is empty, returns undefined.\n     *\n     * The property names correspond to the column names of the result set.\n     * It is impossible to access them by column index; the only supported way is by column name.\n     *\n     * @param {string} sql The SQL query to run.\n     *\n     * @param {any} [params, ...] When the SQL statement contains placeholders, you\n     * can pass them in here. They will be bound to the statement before it is\n     * executed. There are three ways of passing bind parameters: directly in\n     * the function's arguments, as an array, and as an object for named\n     * parameters. This automatically sanitizes inputs.\n     *\n     * @see https://github.com/mapbox/node-sqlite3/wiki/API#databasegetsql-param--callback\n     */\n    get(sql, ...params) {\n        return new Promise((resolve, reject) => {\n            const sqlObj = (0, strings_1.toSqlParams)(sql, params);\n            this.db.get(sqlObj.sql, ...sqlObj.params, (err, row) => {\n                if (err) {\n                    return reject((0, format_error_1.formatError)(err));\n                }\n                resolve(row);\n            });\n        });\n    }\n    each(sql, ...params) {\n        return new Promise((resolve, reject) => {\n            const callback = params.pop();\n            if (!callback || typeof callback !== 'function') {\n                throw new Error('sqlite: Last param of Database#each() must be a callback function');\n            }\n            if (params.length > 0) {\n                const positional = params.pop();\n                if (typeof positional === 'function') {\n                    throw new Error('sqlite: Database#each() should only have a single callback defined. See readme for usage.');\n                }\n                params.push(positional);\n            }\n            const sqlObj = (0, strings_1.toSqlParams)(sql, params);\n            this.db.each(sqlObj.sql, ...sqlObj.params, (err, row) => {\n                if (err) {\n                    return callback((0, format_error_1.formatError)(err), null);\n                }\n                callback(null, row);\n            }, (err, count) => {\n                if (err) {\n                    return reject((0, format_error_1.formatError)(err));\n                }\n                resolve(count);\n            });\n        });\n    }\n    /**\n     * Runs the SQL query with the specified parameters. The parameters are the same as the\n     * Database#run function, with the following differences:\n     *\n     * If the result set is empty, it will be an empty array, otherwise it will\n     * have an object for each result row which\n     * in turn contains the values of that row, like the Database#get function.\n     *\n     * Note that it first retrieves all result rows and stores them in memory.\n     * For queries that have potentially large result sets, use the Database#each\n     * function to retrieve all rows or Database#prepare followed by multiple\n     * Statement#get calls to retrieve a previously unknown amount of rows.\n     *\n     * @param {string} sql The SQL query to run.\n     *\n     * @param {any} [params, ...] When the SQL statement contains placeholders, you\n     * can pass them in here. They will be bound to the statement before it is\n     * executed. There are three ways of passing bind parameters: directly in\n     * the function's arguments, as an array, and as an object for named\n     * parameters. This automatically sanitizes inputs.\n     *\n     * @see https://github.com/mapbox/node-sqlite3/wiki/API#databaseallsql-param--callback\n     */\n    all(sql, ...params) {\n        return new Promise((resolve, reject) => {\n            const sqlObj = (0, strings_1.toSqlParams)(sql, params);\n            this.db.all(sqlObj.sql, ...sqlObj.params, (err, rows) => {\n                if (err) {\n                    return reject((0, format_error_1.formatError)(err));\n                }\n                resolve(rows);\n            });\n        });\n    }\n    /**\n     * Runs all SQL queries in the supplied string. No result rows are retrieved. If a query fails,\n     * no subsequent statements will be executed (wrap it in a transaction if you want all\n     * or none to be executed).\n     *\n     * Note: This function will only execute statements up to the first NULL byte.\n     * Comments are not allowed and will lead to runtime errors.\n     *\n     * @param {string} sql The SQL query to run.\n     * @see https://github.com/mapbox/node-sqlite3/wiki/API#databaseexecsql-callback\n     */\n    exec(sql) {\n        return new Promise((resolve, reject) => {\n            const sqlObj = (0, strings_1.toSqlParams)(sql);\n            this.db.exec(sqlObj.sql, err => {\n                if (err) {\n                    return reject((0, format_error_1.formatError)(err));\n                }\n                resolve();\n            });\n        });\n    }\n    /**\n     * Prepares the SQL statement and optionally binds the specified parameters.\n     * When bind parameters are supplied, they are bound to the prepared statement.\n     *\n     * @param {string} sql The SQL query to run.\n     * @param {any} [params, ...] When the SQL statement contains placeholders, you\n     * can pass them in here. They will be bound to the statement before it is\n     * executed. There are three ways of passing bind parameters: directly in\n     * the function's arguments, as an array, and as an object for named\n     * parameters. This automatically sanitizes inputs.\n     * @returns Promise<Statement> Statement object\n     */\n    prepare(sql, ...params) {\n        return new Promise((resolve, reject) => {\n            const sqlObj = (0, strings_1.toSqlParams)(sql, params);\n            const stmt = this.db.prepare(sqlObj.sql, ...sqlObj.params, err => {\n                if (err) {\n                    return reject(err);\n                }\n                resolve(new Statement_1.Statement(stmt));\n            });\n        });\n    }\n    /**\n     * Loads a compiled SQLite extension into the database connection object.\n     *\n     * @param {string} path Filename of the extension to load\n     */\n    loadExtension(path) {\n        return new Promise((resolve, reject) => {\n            this.db.loadExtension(path, err => {\n                if (err) {\n                    return reject((0, format_error_1.formatError)(err));\n                }\n                resolve();\n            });\n        });\n    }\n    /**\n     * Performs a database migration.\n     */\n    async migrate(config) {\n        await (0, migrate_1.migrate)(this, config);\n    }\n    /**\n     * The methods underneath requires creative work to implement. PRs / proposals accepted!\n     */\n    /*\n     * Unsure if serialize can be made into a promise.\n     */\n    serialize() {\n        throw new Error('sqlite: Currently not implemented. Use getDatabaseInstance().serialize() instead.');\n    }\n    /*\n     * Unsure if parallelize can be made into a promise.\n     */\n    parallelize() {\n        throw new Error('sqlite: Currently not implemented. Use getDatabaseInstance().parallelize() instead.');\n    }\n}\nexports.Database = Database;\n//# sourceMappingURL=Database.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc3FsaXRlL2J1aWxkL0RhdGFiYXNlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQjtBQUNoQixvQkFBb0IsbUJBQU8sQ0FBQyxtRUFBYTtBQUN6QyxrQkFBa0IsbUJBQU8sQ0FBQywyRUFBaUI7QUFDM0Msa0JBQWtCLG1CQUFPLENBQUMsMkVBQWlCO0FBQzNDLHVCQUF1QixtQkFBTyxDQUFDLHFGQUFzQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHlCQUF5QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZUFBZSxLQUFLO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGVBQWUsS0FBSztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxlQUFlLEtBQUs7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxLQUFLO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcSW1hbmdcXERvY3VtZW50c1xcR2l0SHViXFxzZWxmLWNsYWltLWxpbmtcXG5vZGVfbW9kdWxlc1xcc3FsaXRlXFxidWlsZFxcRGF0YWJhc2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkRhdGFiYXNlID0gdm9pZCAwO1xuY29uc3QgU3RhdGVtZW50XzEgPSByZXF1aXJlKFwiLi9TdGF0ZW1lbnRcIik7XG5jb25zdCBtaWdyYXRlXzEgPSByZXF1aXJlKFwiLi91dGlscy9taWdyYXRlXCIpO1xuY29uc3Qgc3RyaW5nc18xID0gcmVxdWlyZShcIi4vdXRpbHMvc3RyaW5nc1wiKTtcbmNvbnN0IGZvcm1hdF9lcnJvcl8xID0gcmVxdWlyZShcIi4vdXRpbHMvZm9ybWF0LWVycm9yXCIpO1xuLyoqXG4gKiBQcm9taXNpZmllZCB3cmFwcGVyIGZvciB0aGUgc3FsaXRlMyNEYXRhYmFzZSBpbnRlcmZhY2UuXG4gKi9cbmNsYXNzIERhdGFiYXNlIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICAgIHRoaXMuZGIgPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFdmVudCBoYW5kbGVyIHdoZW4gdmVyYm9zZSBtb2RlIGlzIGVuYWJsZWQuXG4gICAgICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vbWFwYm94L25vZGUtc3FsaXRlMy93aWtpL0RlYnVnZ2luZ1xuICAgICAqL1xuICAgIG9uKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLmRiLm9uKGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHVuZGVybHlpbmcgc3FsaXRlMyBEYXRhYmFzZSBpbnN0YW5jZVxuICAgICAqL1xuICAgIGdldERhdGFiYXNlSW5zdGFuY2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPcGVucyB0aGUgZGF0YWJhc2VcbiAgICAgKi9cbiAgICBvcGVuKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgbGV0IHsgZmlsZW5hbWUsIG1vZGUsIGRyaXZlciB9ID0gdGhpcy5jb25maWc7XG4gICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbWFwYm94L25vZGUtc3FsaXRlMy93aWtpL0FQSSNuZXctc3FsaXRlM2RhdGFiYXNlZmlsZW5hbWUtbW9kZS1jYWxsYmFja1xuICAgICAgICAgICAgaWYgKGZpbGVuYW1lID09PSBudWxsIHx8IGZpbGVuYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NxbGl0ZTogZmlsZW5hbWUgY2Fubm90IGJlIG51bGwgLyB1bmRlZmluZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZHJpdmVyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzcWxpdGU6IGRyaXZlciBpcyBub3QgZGVmaW5lZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1vZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRiID0gbmV3IGRyaXZlcihmaWxlbmFtZSwgbW9kZSwgZXJyID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdCgoMCwgZm9ybWF0X2Vycm9yXzEuZm9ybWF0RXJyb3IpKGVycikpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZGIgPSBuZXcgZHJpdmVyKGZpbGVuYW1lLCBlcnIgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KCgwLCBmb3JtYXRfZXJyb3JfMS5mb3JtYXRFcnJvcikoZXJyKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xvc2VzIHRoZSBkYXRhYmFzZS5cbiAgICAgKi9cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZGIuY2xvc2UoZXJyID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoKDAsIGZvcm1hdF9lcnJvcl8xLmZvcm1hdEVycm9yKShlcnIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXBib3gvbm9kZS1zcWxpdGUzL3dpa2kvQVBJI2RhdGFiYXNlY29uZmlndXJlb3B0aW9uLXZhbHVlXG4gICAgICovXG4gICAgY29uZmlndXJlKG9wdGlvbiwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5kYi5jb25maWd1cmUob3B0aW9uLCB2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJ1bnMgdGhlIFNRTCBxdWVyeSB3aXRoIHRoZSBzcGVjaWZpZWQgcGFyYW1ldGVycy4gSXQgZG9lcyBub3QgcmV0cmlldmUgYW55IHJlc3VsdCBkYXRhLlxuICAgICAqIFRoZSBmdW5jdGlvbiByZXR1cm5zIHRoZSBEYXRhYmFzZSBvYmplY3QgZm9yIHdoaWNoIGl0IHdhcyBjYWxsZWQgdG8gYWxsb3cgZm9yIGZ1bmN0aW9uIGNoYWluaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNxbCBUaGUgU1FMIHF1ZXJ5IHRvIHJ1bi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7YW55fSBbcGFyYW1zLCAuLi5dIFdoZW4gdGhlIFNRTCBzdGF0ZW1lbnQgY29udGFpbnMgcGxhY2Vob2xkZXJzLCB5b3VcbiAgICAgKiBjYW4gcGFzcyB0aGVtIGluIGhlcmUuIFRoZXkgd2lsbCBiZSBib3VuZCB0byB0aGUgc3RhdGVtZW50IGJlZm9yZSBpdCBpc1xuICAgICAqIGV4ZWN1dGVkLiBUaGVyZSBhcmUgdGhyZWUgd2F5cyBvZiBwYXNzaW5nIGJpbmQgcGFyYW1ldGVyczogZGlyZWN0bHkgaW5cbiAgICAgKiB0aGUgZnVuY3Rpb24ncyBhcmd1bWVudHMsIGFzIGFuIGFycmF5LCBhbmQgYXMgYW4gb2JqZWN0IGZvciBuYW1lZFxuICAgICAqIHBhcmFtZXRlcnMuIFRoaXMgYXV0b21hdGljYWxseSBzYW5pdGl6ZXMgaW5wdXRzLlxuICAgICAqXG4gICAgICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vbWFwYm94L25vZGUtc3FsaXRlMy93aWtpL0FQSSNkYXRhYmFzZXJ1bnNxbC1wYXJhbS0tY2FsbGJhY2tcbiAgICAgKi9cbiAgICBydW4oc3FsLCAuLi5wYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNxbE9iaiA9ICgwLCBzdHJpbmdzXzEudG9TcWxQYXJhbXMpKHNxbCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHRoaXMuZGIucnVuKHNxbE9iai5zcWwsIC4uLnNxbE9iai5wYXJhbXMsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoKDAsIGZvcm1hdF9lcnJvcl8xLmZvcm1hdEVycm9yKShlcnIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgICAgIHN0bXQ6IG5ldyBTdGF0ZW1lbnRfMS5TdGF0ZW1lbnQodGhpcy5zdG10KSxcbiAgICAgICAgICAgICAgICAgICAgbGFzdElEOiB0aGlzLmxhc3RJRCxcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlczogdGhpcy5jaGFuZ2VzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJ1bnMgdGhlIFNRTCBxdWVyeSB3aXRoIHRoZSBzcGVjaWZpZWQgcGFyYW1ldGVycyBhbmQgcmVzb2x2ZXMgd2l0aFxuICAgICAqIHdpdGggdGhlIGZpcnN0IHJlc3VsdCByb3cgYWZ0ZXJ3YXJkcy4gSWYgdGhlIHJlc3VsdCBzZXQgaXMgZW1wdHksIHJldHVybnMgdW5kZWZpbmVkLlxuICAgICAqXG4gICAgICogVGhlIHByb3BlcnR5IG5hbWVzIGNvcnJlc3BvbmQgdG8gdGhlIGNvbHVtbiBuYW1lcyBvZiB0aGUgcmVzdWx0IHNldC5cbiAgICAgKiBJdCBpcyBpbXBvc3NpYmxlIHRvIGFjY2VzcyB0aGVtIGJ5IGNvbHVtbiBpbmRleDsgdGhlIG9ubHkgc3VwcG9ydGVkIHdheSBpcyBieSBjb2x1bW4gbmFtZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzcWwgVGhlIFNRTCBxdWVyeSB0byBydW4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2FueX0gW3BhcmFtcywgLi4uXSBXaGVuIHRoZSBTUUwgc3RhdGVtZW50IGNvbnRhaW5zIHBsYWNlaG9sZGVycywgeW91XG4gICAgICogY2FuIHBhc3MgdGhlbSBpbiBoZXJlLiBUaGV5IHdpbGwgYmUgYm91bmQgdG8gdGhlIHN0YXRlbWVudCBiZWZvcmUgaXQgaXNcbiAgICAgKiBleGVjdXRlZC4gVGhlcmUgYXJlIHRocmVlIHdheXMgb2YgcGFzc2luZyBiaW5kIHBhcmFtZXRlcnM6IGRpcmVjdGx5IGluXG4gICAgICogdGhlIGZ1bmN0aW9uJ3MgYXJndW1lbnRzLCBhcyBhbiBhcnJheSwgYW5kIGFzIGFuIG9iamVjdCBmb3IgbmFtZWRcbiAgICAgKiBwYXJhbWV0ZXJzLiBUaGlzIGF1dG9tYXRpY2FsbHkgc2FuaXRpemVzIGlucHV0cy5cbiAgICAgKlxuICAgICAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL21hcGJveC9ub2RlLXNxbGl0ZTMvd2lraS9BUEkjZGF0YWJhc2VnZXRzcWwtcGFyYW0tLWNhbGxiYWNrXG4gICAgICovXG4gICAgZ2V0KHNxbCwgLi4ucGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzcWxPYmogPSAoMCwgc3RyaW5nc18xLnRvU3FsUGFyYW1zKShzcWwsIHBhcmFtcyk7XG4gICAgICAgICAgICB0aGlzLmRiLmdldChzcWxPYmouc3FsLCAuLi5zcWxPYmoucGFyYW1zLCAoZXJyLCByb3cpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoKDAsIGZvcm1hdF9lcnJvcl8xLmZvcm1hdEVycm9yKShlcnIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyb3cpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlYWNoKHNxbCwgLi4ucGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjYWxsYmFjayA9IHBhcmFtcy5wb3AoKTtcbiAgICAgICAgICAgIGlmICghY2FsbGJhY2sgfHwgdHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzcWxpdGU6IExhc3QgcGFyYW0gb2YgRGF0YWJhc2UjZWFjaCgpIG11c3QgYmUgYSBjYWxsYmFjayBmdW5jdGlvbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcG9zaXRpb25hbCA9IHBhcmFtcy5wb3AoKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHBvc2l0aW9uYWwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzcWxpdGU6IERhdGFiYXNlI2VhY2goKSBzaG91bGQgb25seSBoYXZlIGEgc2luZ2xlIGNhbGxiYWNrIGRlZmluZWQuIFNlZSByZWFkbWUgZm9yIHVzYWdlLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXJhbXMucHVzaChwb3NpdGlvbmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNxbE9iaiA9ICgwLCBzdHJpbmdzXzEudG9TcWxQYXJhbXMpKHNxbCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHRoaXMuZGIuZWFjaChzcWxPYmouc3FsLCAuLi5zcWxPYmoucGFyYW1zLCAoZXJyLCByb3cpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjaygoMCwgZm9ybWF0X2Vycm9yXzEuZm9ybWF0RXJyb3IpKGVyciksIG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCByb3cpO1xuICAgICAgICAgICAgfSwgKGVyciwgY291bnQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoKDAsIGZvcm1hdF9lcnJvcl8xLmZvcm1hdEVycm9yKShlcnIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShjb3VudCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJ1bnMgdGhlIFNRTCBxdWVyeSB3aXRoIHRoZSBzcGVjaWZpZWQgcGFyYW1ldGVycy4gVGhlIHBhcmFtZXRlcnMgYXJlIHRoZSBzYW1lIGFzIHRoZVxuICAgICAqIERhdGFiYXNlI3J1biBmdW5jdGlvbiwgd2l0aCB0aGUgZm9sbG93aW5nIGRpZmZlcmVuY2VzOlxuICAgICAqXG4gICAgICogSWYgdGhlIHJlc3VsdCBzZXQgaXMgZW1wdHksIGl0IHdpbGwgYmUgYW4gZW1wdHkgYXJyYXksIG90aGVyd2lzZSBpdCB3aWxsXG4gICAgICogaGF2ZSBhbiBvYmplY3QgZm9yIGVhY2ggcmVzdWx0IHJvdyB3aGljaFxuICAgICAqIGluIHR1cm4gY29udGFpbnMgdGhlIHZhbHVlcyBvZiB0aGF0IHJvdywgbGlrZSB0aGUgRGF0YWJhc2UjZ2V0IGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IGl0IGZpcnN0IHJldHJpZXZlcyBhbGwgcmVzdWx0IHJvd3MgYW5kIHN0b3JlcyB0aGVtIGluIG1lbW9yeS5cbiAgICAgKiBGb3IgcXVlcmllcyB0aGF0IGhhdmUgcG90ZW50aWFsbHkgbGFyZ2UgcmVzdWx0IHNldHMsIHVzZSB0aGUgRGF0YWJhc2UjZWFjaFxuICAgICAqIGZ1bmN0aW9uIHRvIHJldHJpZXZlIGFsbCByb3dzIG9yIERhdGFiYXNlI3ByZXBhcmUgZm9sbG93ZWQgYnkgbXVsdGlwbGVcbiAgICAgKiBTdGF0ZW1lbnQjZ2V0IGNhbGxzIHRvIHJldHJpZXZlIGEgcHJldmlvdXNseSB1bmtub3duIGFtb3VudCBvZiByb3dzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNxbCBUaGUgU1FMIHF1ZXJ5IHRvIHJ1bi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7YW55fSBbcGFyYW1zLCAuLi5dIFdoZW4gdGhlIFNRTCBzdGF0ZW1lbnQgY29udGFpbnMgcGxhY2Vob2xkZXJzLCB5b3VcbiAgICAgKiBjYW4gcGFzcyB0aGVtIGluIGhlcmUuIFRoZXkgd2lsbCBiZSBib3VuZCB0byB0aGUgc3RhdGVtZW50IGJlZm9yZSBpdCBpc1xuICAgICAqIGV4ZWN1dGVkLiBUaGVyZSBhcmUgdGhyZWUgd2F5cyBvZiBwYXNzaW5nIGJpbmQgcGFyYW1ldGVyczogZGlyZWN0bHkgaW5cbiAgICAgKiB0aGUgZnVuY3Rpb24ncyBhcmd1bWVudHMsIGFzIGFuIGFycmF5LCBhbmQgYXMgYW4gb2JqZWN0IGZvciBuYW1lZFxuICAgICAqIHBhcmFtZXRlcnMuIFRoaXMgYXV0b21hdGljYWxseSBzYW5pdGl6ZXMgaW5wdXRzLlxuICAgICAqXG4gICAgICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vbWFwYm94L25vZGUtc3FsaXRlMy93aWtpL0FQSSNkYXRhYmFzZWFsbHNxbC1wYXJhbS0tY2FsbGJhY2tcbiAgICAgKi9cbiAgICBhbGwoc3FsLCAuLi5wYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNxbE9iaiA9ICgwLCBzdHJpbmdzXzEudG9TcWxQYXJhbXMpKHNxbCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHRoaXMuZGIuYWxsKHNxbE9iai5zcWwsIC4uLnNxbE9iai5wYXJhbXMsIChlcnIsIHJvd3MpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoKDAsIGZvcm1hdF9lcnJvcl8xLmZvcm1hdEVycm9yKShlcnIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyb3dzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUnVucyBhbGwgU1FMIHF1ZXJpZXMgaW4gdGhlIHN1cHBsaWVkIHN0cmluZy4gTm8gcmVzdWx0IHJvd3MgYXJlIHJldHJpZXZlZC4gSWYgYSBxdWVyeSBmYWlscyxcbiAgICAgKiBubyBzdWJzZXF1ZW50IHN0YXRlbWVudHMgd2lsbCBiZSBleGVjdXRlZCAod3JhcCBpdCBpbiBhIHRyYW5zYWN0aW9uIGlmIHlvdSB3YW50IGFsbFxuICAgICAqIG9yIG5vbmUgdG8gYmUgZXhlY3V0ZWQpLlxuICAgICAqXG4gICAgICogTm90ZTogVGhpcyBmdW5jdGlvbiB3aWxsIG9ubHkgZXhlY3V0ZSBzdGF0ZW1lbnRzIHVwIHRvIHRoZSBmaXJzdCBOVUxMIGJ5dGUuXG4gICAgICogQ29tbWVudHMgYXJlIG5vdCBhbGxvd2VkIGFuZCB3aWxsIGxlYWQgdG8gcnVudGltZSBlcnJvcnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3FsIFRoZSBTUUwgcXVlcnkgdG8gcnVuLlxuICAgICAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL21hcGJveC9ub2RlLXNxbGl0ZTMvd2lraS9BUEkjZGF0YWJhc2VleGVjc3FsLWNhbGxiYWNrXG4gICAgICovXG4gICAgZXhlYyhzcWwpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNxbE9iaiA9ICgwLCBzdHJpbmdzXzEudG9TcWxQYXJhbXMpKHNxbCk7XG4gICAgICAgICAgICB0aGlzLmRiLmV4ZWMoc3FsT2JqLnNxbCwgZXJyID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoKDAsIGZvcm1hdF9lcnJvcl8xLmZvcm1hdEVycm9yKShlcnIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcmVwYXJlcyB0aGUgU1FMIHN0YXRlbWVudCBhbmQgb3B0aW9uYWxseSBiaW5kcyB0aGUgc3BlY2lmaWVkIHBhcmFtZXRlcnMuXG4gICAgICogV2hlbiBiaW5kIHBhcmFtZXRlcnMgYXJlIHN1cHBsaWVkLCB0aGV5IGFyZSBib3VuZCB0byB0aGUgcHJlcGFyZWQgc3RhdGVtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNxbCBUaGUgU1FMIHF1ZXJ5IHRvIHJ1bi5cbiAgICAgKiBAcGFyYW0ge2FueX0gW3BhcmFtcywgLi4uXSBXaGVuIHRoZSBTUUwgc3RhdGVtZW50IGNvbnRhaW5zIHBsYWNlaG9sZGVycywgeW91XG4gICAgICogY2FuIHBhc3MgdGhlbSBpbiBoZXJlLiBUaGV5IHdpbGwgYmUgYm91bmQgdG8gdGhlIHN0YXRlbWVudCBiZWZvcmUgaXQgaXNcbiAgICAgKiBleGVjdXRlZC4gVGhlcmUgYXJlIHRocmVlIHdheXMgb2YgcGFzc2luZyBiaW5kIHBhcmFtZXRlcnM6IGRpcmVjdGx5IGluXG4gICAgICogdGhlIGZ1bmN0aW9uJ3MgYXJndW1lbnRzLCBhcyBhbiBhcnJheSwgYW5kIGFzIGFuIG9iamVjdCBmb3IgbmFtZWRcbiAgICAgKiBwYXJhbWV0ZXJzLiBUaGlzIGF1dG9tYXRpY2FsbHkgc2FuaXRpemVzIGlucHV0cy5cbiAgICAgKiBAcmV0dXJucyBQcm9taXNlPFN0YXRlbWVudD4gU3RhdGVtZW50IG9iamVjdFxuICAgICAqL1xuICAgIHByZXBhcmUoc3FsLCAuLi5wYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNxbE9iaiA9ICgwLCBzdHJpbmdzXzEudG9TcWxQYXJhbXMpKHNxbCwgcGFyYW1zKTtcbiAgICAgICAgICAgIGNvbnN0IHN0bXQgPSB0aGlzLmRiLnByZXBhcmUoc3FsT2JqLnNxbCwgLi4uc3FsT2JqLnBhcmFtcywgZXJyID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShuZXcgU3RhdGVtZW50XzEuU3RhdGVtZW50KHN0bXQpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9hZHMgYSBjb21waWxlZCBTUUxpdGUgZXh0ZW5zaW9uIGludG8gdGhlIGRhdGFiYXNlIGNvbm5lY3Rpb24gb2JqZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggRmlsZW5hbWUgb2YgdGhlIGV4dGVuc2lvbiB0byBsb2FkXG4gICAgICovXG4gICAgbG9hZEV4dGVuc2lvbihwYXRoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmRiLmxvYWRFeHRlbnNpb24ocGF0aCwgZXJyID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoKDAsIGZvcm1hdF9lcnJvcl8xLmZvcm1hdEVycm9yKShlcnIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBhIGRhdGFiYXNlIG1pZ3JhdGlvbi5cbiAgICAgKi9cbiAgICBhc3luYyBtaWdyYXRlKGNvbmZpZykge1xuICAgICAgICBhd2FpdCAoMCwgbWlncmF0ZV8xLm1pZ3JhdGUpKHRoaXMsIGNvbmZpZyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBtZXRob2RzIHVuZGVybmVhdGggcmVxdWlyZXMgY3JlYXRpdmUgd29yayB0byBpbXBsZW1lbnQuIFBScyAvIHByb3Bvc2FscyBhY2NlcHRlZCFcbiAgICAgKi9cbiAgICAvKlxuICAgICAqIFVuc3VyZSBpZiBzZXJpYWxpemUgY2FuIGJlIG1hZGUgaW50byBhIHByb21pc2UuXG4gICAgICovXG4gICAgc2VyaWFsaXplKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NxbGl0ZTogQ3VycmVudGx5IG5vdCBpbXBsZW1lbnRlZC4gVXNlIGdldERhdGFiYXNlSW5zdGFuY2UoKS5zZXJpYWxpemUoKSBpbnN0ZWFkLicpO1xuICAgIH1cbiAgICAvKlxuICAgICAqIFVuc3VyZSBpZiBwYXJhbGxlbGl6ZSBjYW4gYmUgbWFkZSBpbnRvIGEgcHJvbWlzZS5cbiAgICAgKi9cbiAgICBwYXJhbGxlbGl6ZSgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzcWxpdGU6IEN1cnJlbnRseSBub3QgaW1wbGVtZW50ZWQuIFVzZSBnZXREYXRhYmFzZUluc3RhbmNlKCkucGFyYWxsZWxpemUoKSBpbnN0ZWFkLicpO1xuICAgIH1cbn1cbmV4cG9ydHMuRGF0YWJhc2UgPSBEYXRhYmFzZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURhdGFiYXNlLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sqlite/build/Database.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sqlite/build/Statement.js":
/*!************************************************!*\
  !*** ./node_modules/sqlite/build/Statement.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Statement = void 0;\nconst format_error_1 = __webpack_require__(/*! ./utils/format-error */ \"(rsc)/./node_modules/sqlite/build/utils/format-error.js\");\n/**\n * Promisified wrapper for the sqlite3#Statement interface.\n */\nclass Statement {\n    constructor(stmt) {\n        this.stmt = stmt;\n    }\n    /**\n     * Returns the underlying sqlite3 Statement instance\n     */\n    getStatementInstance() {\n        return this.stmt;\n    }\n    /**\n     * Binds parameters to the prepared statement.\n     *\n     * Binding parameters with this function completely resets the statement object and row cursor\n     * and removes all previously bound parameters, if any.\n     */\n    bind(...params) {\n        return new Promise((resolve, reject) => {\n            this.stmt.bind(...params, err => {\n                if (err) {\n                    return reject((0, format_error_1.formatError)(err));\n                }\n                resolve();\n            });\n        });\n    }\n    /**\n     * Resets the row cursor of the statement and preserves the parameter bindings.\n     * Use this function to re-execute the same query with the same bindings.\n     */\n    reset() {\n        return new Promise(resolve => {\n            this.stmt.reset(() => {\n                resolve();\n            });\n        });\n    }\n    /**\n     * Finalizes the statement. This is typically optional, but if you experience long delays before\n     * the next query is executed, explicitly finalizing your statement might be necessary.\n     * This might be the case when you run an exclusive query (see section Control Flow).\n     * After the statement is finalized, all further function calls on that statement object\n     * will throw errors.\n     */\n    finalize() {\n        return new Promise((resolve, reject) => {\n            this.stmt.finalize(err => {\n                if (err) {\n                    return reject((0, format_error_1.formatError)(err));\n                }\n                resolve();\n            });\n        });\n    }\n    /**\n     * Binds parameters and executes the statement.\n     *\n     * If you specify bind parameters, they will be bound to the statement before it is executed.\n     * Note that the bindings and the row cursor are reset when you specify even a single bind parameter.\n     *\n     * The execution behavior is identical to the Database#run method with the difference that the\n     * statement will not be finalized after it is run. This means you can run it multiple times.\n     *\n     * @param {any} [params, ...] When the SQL statement contains placeholders, you\n     * can pass them in here. They will be bound to the statement before it is\n     * executed. There are three ways of passing bind parameters: directly in\n     * the function's arguments, as an array, and as an object for named\n     * parameters. This automatically sanitizes inputs.\n     */\n    run(...params) {\n        return new Promise((resolve, reject) => {\n            const stmt = this;\n            this.stmt.run(...params, function (err) {\n                if (err) {\n                    return reject((0, format_error_1.formatError)(err));\n                }\n                resolve({\n                    stmt,\n                    lastID: this.lastID,\n                    changes: this.changes\n                });\n            });\n        });\n    }\n    /**\n     * Binds parameters, executes the statement and retrieves the first result row.\n     * The parameters are the same as the Statement#run function, with the following differences:\n     *\n     * Using this method can leave the database locked, as the database awaits further\n     * calls to Statement#get to retrieve subsequent rows. To inform the database that you\n     * are finished retrieving rows, you should either finalize (with Statement#finalize)\n     * or reset (with Statement#reset) the statement.\n     *\n     * @param {any} [params, ...] When the SQL statement contains placeholders, you\n     * can pass them in here. They will be bound to the statement before it is\n     * executed. There are three ways of passing bind parameters: directly in\n     * the function's arguments, as an array, and as an object for named\n     * parameters. This automatically sanitizes inputs.\n     */\n    get(...params) {\n        return new Promise((resolve, reject) => {\n            this.stmt.get(...params, (err, row) => {\n                if (err) {\n                    return reject((0, format_error_1.formatError)(err));\n                }\n                resolve(row);\n            });\n        });\n    }\n    /**\n     * Binds parameters, executes the statement and calls the callback with all result rows.\n     * The parameters are the same as the Statement#run function, with the following differences:\n     *\n     * If the result set is empty, it will resolve to an empty array, otherwise it contains an\n     * object for each result row which in turn contains the values of that row.\n     * Like with Statement#run, the statement will not be finalized after executing this function.\n     *\n     * @param {any} [params, ...] When the SQL statement contains placeholders, you\n     * can pass them in here. They will be bound to the statement before it is\n     * executed. There are three ways of passing bind parameters: directly in\n     * the function's arguments, as an array, and as an object for named\n     * parameters. This automatically sanitizes inputs.\n     *\n     * @see https://github.com/mapbox/node-sqlite3/wiki/API#databaseallsql-param--callback\n     */\n    all(...params) {\n        return new Promise((resolve, reject) => {\n            this.stmt.all(...params, (err, rows) => {\n                if (err) {\n                    return reject((0, format_error_1.formatError)(err));\n                }\n                resolve(rows);\n            });\n        });\n    }\n    each(...params) {\n        return new Promise((resolve, reject) => {\n            const callback = params.pop();\n            if (!callback || typeof callback !== 'function') {\n                throw new Error('sqlite: Last param of Statement#each() must be a callback function');\n            }\n            if (params.length > 0) {\n                const positional = params.pop();\n                if (typeof positional === 'function') {\n                    throw new Error('sqlite: Statement#each() should only have a single callback defined. See readme for usage.');\n                }\n                params.push(positional);\n            }\n            this.stmt.each(...params, (err, row) => {\n                if (err) {\n                    return callback((0, format_error_1.formatError)(err), null);\n                }\n                callback(null, row);\n            }, (err, count) => {\n                if (err) {\n                    return reject((0, format_error_1.formatError)(err));\n                }\n                resolve(count);\n            });\n        });\n    }\n}\nexports.Statement = Statement;\n//# sourceMappingURL=Statement.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc3FsaXRlL2J1aWxkL1N0YXRlbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQkFBaUI7QUFDakIsdUJBQXVCLG1CQUFPLENBQUMscUZBQXNCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsS0FBSztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxLQUFLO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxLQUFLO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEltYW5nXFxEb2N1bWVudHNcXEdpdEh1Ylxcc2VsZi1jbGFpbS1saW5rXFxub2RlX21vZHVsZXNcXHNxbGl0ZVxcYnVpbGRcXFN0YXRlbWVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU3RhdGVtZW50ID0gdm9pZCAwO1xuY29uc3QgZm9ybWF0X2Vycm9yXzEgPSByZXF1aXJlKFwiLi91dGlscy9mb3JtYXQtZXJyb3JcIik7XG4vKipcbiAqIFByb21pc2lmaWVkIHdyYXBwZXIgZm9yIHRoZSBzcWxpdGUzI1N0YXRlbWVudCBpbnRlcmZhY2UuXG4gKi9cbmNsYXNzIFN0YXRlbWVudCB7XG4gICAgY29uc3RydWN0b3Ioc3RtdCkge1xuICAgICAgICB0aGlzLnN0bXQgPSBzdG10O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB1bmRlcmx5aW5nIHNxbGl0ZTMgU3RhdGVtZW50IGluc3RhbmNlXG4gICAgICovXG4gICAgZ2V0U3RhdGVtZW50SW5zdGFuY2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0bXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJpbmRzIHBhcmFtZXRlcnMgdG8gdGhlIHByZXBhcmVkIHN0YXRlbWVudC5cbiAgICAgKlxuICAgICAqIEJpbmRpbmcgcGFyYW1ldGVycyB3aXRoIHRoaXMgZnVuY3Rpb24gY29tcGxldGVseSByZXNldHMgdGhlIHN0YXRlbWVudCBvYmplY3QgYW5kIHJvdyBjdXJzb3JcbiAgICAgKiBhbmQgcmVtb3ZlcyBhbGwgcHJldmlvdXNseSBib3VuZCBwYXJhbWV0ZXJzLCBpZiBhbnkuXG4gICAgICovXG4gICAgYmluZCguLi5wYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc3RtdC5iaW5kKC4uLnBhcmFtcywgZXJyID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoKDAsIGZvcm1hdF9lcnJvcl8xLmZvcm1hdEVycm9yKShlcnIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNldHMgdGhlIHJvdyBjdXJzb3Igb2YgdGhlIHN0YXRlbWVudCBhbmQgcHJlc2VydmVzIHRoZSBwYXJhbWV0ZXIgYmluZGluZ3MuXG4gICAgICogVXNlIHRoaXMgZnVuY3Rpb24gdG8gcmUtZXhlY3V0ZSB0aGUgc2FtZSBxdWVyeSB3aXRoIHRoZSBzYW1lIGJpbmRpbmdzLlxuICAgICAqL1xuICAgIHJlc2V0KCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgICB0aGlzLnN0bXQucmVzZXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmluYWxpemVzIHRoZSBzdGF0ZW1lbnQuIFRoaXMgaXMgdHlwaWNhbGx5IG9wdGlvbmFsLCBidXQgaWYgeW91IGV4cGVyaWVuY2UgbG9uZyBkZWxheXMgYmVmb3JlXG4gICAgICogdGhlIG5leHQgcXVlcnkgaXMgZXhlY3V0ZWQsIGV4cGxpY2l0bHkgZmluYWxpemluZyB5b3VyIHN0YXRlbWVudCBtaWdodCBiZSBuZWNlc3NhcnkuXG4gICAgICogVGhpcyBtaWdodCBiZSB0aGUgY2FzZSB3aGVuIHlvdSBydW4gYW4gZXhjbHVzaXZlIHF1ZXJ5IChzZWUgc2VjdGlvbiBDb250cm9sIEZsb3cpLlxuICAgICAqIEFmdGVyIHRoZSBzdGF0ZW1lbnQgaXMgZmluYWxpemVkLCBhbGwgZnVydGhlciBmdW5jdGlvbiBjYWxscyBvbiB0aGF0IHN0YXRlbWVudCBvYmplY3RcbiAgICAgKiB3aWxsIHRocm93IGVycm9ycy5cbiAgICAgKi9cbiAgICBmaW5hbGl6ZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc3RtdC5maW5hbGl6ZShlcnIgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdCgoMCwgZm9ybWF0X2Vycm9yXzEuZm9ybWF0RXJyb3IpKGVycikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJpbmRzIHBhcmFtZXRlcnMgYW5kIGV4ZWN1dGVzIHRoZSBzdGF0ZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiB5b3Ugc3BlY2lmeSBiaW5kIHBhcmFtZXRlcnMsIHRoZXkgd2lsbCBiZSBib3VuZCB0byB0aGUgc3RhdGVtZW50IGJlZm9yZSBpdCBpcyBleGVjdXRlZC5cbiAgICAgKiBOb3RlIHRoYXQgdGhlIGJpbmRpbmdzIGFuZCB0aGUgcm93IGN1cnNvciBhcmUgcmVzZXQgd2hlbiB5b3Ugc3BlY2lmeSBldmVuIGEgc2luZ2xlIGJpbmQgcGFyYW1ldGVyLlxuICAgICAqXG4gICAgICogVGhlIGV4ZWN1dGlvbiBiZWhhdmlvciBpcyBpZGVudGljYWwgdG8gdGhlIERhdGFiYXNlI3J1biBtZXRob2Qgd2l0aCB0aGUgZGlmZmVyZW5jZSB0aGF0IHRoZVxuICAgICAqIHN0YXRlbWVudCB3aWxsIG5vdCBiZSBmaW5hbGl6ZWQgYWZ0ZXIgaXQgaXMgcnVuLiBUaGlzIG1lYW5zIHlvdSBjYW4gcnVuIGl0IG11bHRpcGxlIHRpbWVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHthbnl9IFtwYXJhbXMsIC4uLl0gV2hlbiB0aGUgU1FMIHN0YXRlbWVudCBjb250YWlucyBwbGFjZWhvbGRlcnMsIHlvdVxuICAgICAqIGNhbiBwYXNzIHRoZW0gaW4gaGVyZS4gVGhleSB3aWxsIGJlIGJvdW5kIHRvIHRoZSBzdGF0ZW1lbnQgYmVmb3JlIGl0IGlzXG4gICAgICogZXhlY3V0ZWQuIFRoZXJlIGFyZSB0aHJlZSB3YXlzIG9mIHBhc3NpbmcgYmluZCBwYXJhbWV0ZXJzOiBkaXJlY3RseSBpblxuICAgICAqIHRoZSBmdW5jdGlvbidzIGFyZ3VtZW50cywgYXMgYW4gYXJyYXksIGFuZCBhcyBhbiBvYmplY3QgZm9yIG5hbWVkXG4gICAgICogcGFyYW1ldGVycy4gVGhpcyBhdXRvbWF0aWNhbGx5IHNhbml0aXplcyBpbnB1dHMuXG4gICAgICovXG4gICAgcnVuKC4uLnBhcmFtcykge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc3RtdCA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLnN0bXQucnVuKC4uLnBhcmFtcywgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdCgoMCwgZm9ybWF0X2Vycm9yXzEuZm9ybWF0RXJyb3IpKGVycikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgICAgICAgICAgc3RtdCxcbiAgICAgICAgICAgICAgICAgICAgbGFzdElEOiB0aGlzLmxhc3RJRCxcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlczogdGhpcy5jaGFuZ2VzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJpbmRzIHBhcmFtZXRlcnMsIGV4ZWN1dGVzIHRoZSBzdGF0ZW1lbnQgYW5kIHJldHJpZXZlcyB0aGUgZmlyc3QgcmVzdWx0IHJvdy5cbiAgICAgKiBUaGUgcGFyYW1ldGVycyBhcmUgdGhlIHNhbWUgYXMgdGhlIFN0YXRlbWVudCNydW4gZnVuY3Rpb24sIHdpdGggdGhlIGZvbGxvd2luZyBkaWZmZXJlbmNlczpcbiAgICAgKlxuICAgICAqIFVzaW5nIHRoaXMgbWV0aG9kIGNhbiBsZWF2ZSB0aGUgZGF0YWJhc2UgbG9ja2VkLCBhcyB0aGUgZGF0YWJhc2UgYXdhaXRzIGZ1cnRoZXJcbiAgICAgKiBjYWxscyB0byBTdGF0ZW1lbnQjZ2V0IHRvIHJldHJpZXZlIHN1YnNlcXVlbnQgcm93cy4gVG8gaW5mb3JtIHRoZSBkYXRhYmFzZSB0aGF0IHlvdVxuICAgICAqIGFyZSBmaW5pc2hlZCByZXRyaWV2aW5nIHJvd3MsIHlvdSBzaG91bGQgZWl0aGVyIGZpbmFsaXplICh3aXRoIFN0YXRlbWVudCNmaW5hbGl6ZSlcbiAgICAgKiBvciByZXNldCAod2l0aCBTdGF0ZW1lbnQjcmVzZXQpIHRoZSBzdGF0ZW1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2FueX0gW3BhcmFtcywgLi4uXSBXaGVuIHRoZSBTUUwgc3RhdGVtZW50IGNvbnRhaW5zIHBsYWNlaG9sZGVycywgeW91XG4gICAgICogY2FuIHBhc3MgdGhlbSBpbiBoZXJlLiBUaGV5IHdpbGwgYmUgYm91bmQgdG8gdGhlIHN0YXRlbWVudCBiZWZvcmUgaXQgaXNcbiAgICAgKiBleGVjdXRlZC4gVGhlcmUgYXJlIHRocmVlIHdheXMgb2YgcGFzc2luZyBiaW5kIHBhcmFtZXRlcnM6IGRpcmVjdGx5IGluXG4gICAgICogdGhlIGZ1bmN0aW9uJ3MgYXJndW1lbnRzLCBhcyBhbiBhcnJheSwgYW5kIGFzIGFuIG9iamVjdCBmb3IgbmFtZWRcbiAgICAgKiBwYXJhbWV0ZXJzLiBUaGlzIGF1dG9tYXRpY2FsbHkgc2FuaXRpemVzIGlucHV0cy5cbiAgICAgKi9cbiAgICBnZXQoLi4ucGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnN0bXQuZ2V0KC4uLnBhcmFtcywgKGVyciwgcm93KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KCgwLCBmb3JtYXRfZXJyb3JfMS5mb3JtYXRFcnJvcikoZXJyKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc29sdmUocm93KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQmluZHMgcGFyYW1ldGVycywgZXhlY3V0ZXMgdGhlIHN0YXRlbWVudCBhbmQgY2FsbHMgdGhlIGNhbGxiYWNrIHdpdGggYWxsIHJlc3VsdCByb3dzLlxuICAgICAqIFRoZSBwYXJhbWV0ZXJzIGFyZSB0aGUgc2FtZSBhcyB0aGUgU3RhdGVtZW50I3J1biBmdW5jdGlvbiwgd2l0aCB0aGUgZm9sbG93aW5nIGRpZmZlcmVuY2VzOlxuICAgICAqXG4gICAgICogSWYgdGhlIHJlc3VsdCBzZXQgaXMgZW1wdHksIGl0IHdpbGwgcmVzb2x2ZSB0byBhbiBlbXB0eSBhcnJheSwgb3RoZXJ3aXNlIGl0IGNvbnRhaW5zIGFuXG4gICAgICogb2JqZWN0IGZvciBlYWNoIHJlc3VsdCByb3cgd2hpY2ggaW4gdHVybiBjb250YWlucyB0aGUgdmFsdWVzIG9mIHRoYXQgcm93LlxuICAgICAqIExpa2Ugd2l0aCBTdGF0ZW1lbnQjcnVuLCB0aGUgc3RhdGVtZW50IHdpbGwgbm90IGJlIGZpbmFsaXplZCBhZnRlciBleGVjdXRpbmcgdGhpcyBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7YW55fSBbcGFyYW1zLCAuLi5dIFdoZW4gdGhlIFNRTCBzdGF0ZW1lbnQgY29udGFpbnMgcGxhY2Vob2xkZXJzLCB5b3VcbiAgICAgKiBjYW4gcGFzcyB0aGVtIGluIGhlcmUuIFRoZXkgd2lsbCBiZSBib3VuZCB0byB0aGUgc3RhdGVtZW50IGJlZm9yZSBpdCBpc1xuICAgICAqIGV4ZWN1dGVkLiBUaGVyZSBhcmUgdGhyZWUgd2F5cyBvZiBwYXNzaW5nIGJpbmQgcGFyYW1ldGVyczogZGlyZWN0bHkgaW5cbiAgICAgKiB0aGUgZnVuY3Rpb24ncyBhcmd1bWVudHMsIGFzIGFuIGFycmF5LCBhbmQgYXMgYW4gb2JqZWN0IGZvciBuYW1lZFxuICAgICAqIHBhcmFtZXRlcnMuIFRoaXMgYXV0b21hdGljYWxseSBzYW5pdGl6ZXMgaW5wdXRzLlxuICAgICAqXG4gICAgICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vbWFwYm94L25vZGUtc3FsaXRlMy93aWtpL0FQSSNkYXRhYmFzZWFsbHNxbC1wYXJhbS0tY2FsbGJhY2tcbiAgICAgKi9cbiAgICBhbGwoLi4ucGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnN0bXQuYWxsKC4uLnBhcmFtcywgKGVyciwgcm93cykgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdCgoMCwgZm9ybWF0X2Vycm9yXzEuZm9ybWF0RXJyb3IpKGVycikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXNvbHZlKHJvd3MpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlYWNoKC4uLnBhcmFtcykge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY2FsbGJhY2sgPSBwYXJhbXMucG9wKCk7XG4gICAgICAgICAgICBpZiAoIWNhbGxiYWNrIHx8IHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc3FsaXRlOiBMYXN0IHBhcmFtIG9mIFN0YXRlbWVudCNlYWNoKCkgbXVzdCBiZSBhIGNhbGxiYWNrIGZ1bmN0aW9uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwb3NpdGlvbmFsID0gcGFyYW1zLnBvcCgpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcG9zaXRpb25hbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NxbGl0ZTogU3RhdGVtZW50I2VhY2goKSBzaG91bGQgb25seSBoYXZlIGEgc2luZ2xlIGNhbGxiYWNrIGRlZmluZWQuIFNlZSByZWFkbWUgZm9yIHVzYWdlLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXJhbXMucHVzaChwb3NpdGlvbmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc3RtdC5lYWNoKC4uLnBhcmFtcywgKGVyciwgcm93KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKDAsIGZvcm1hdF9lcnJvcl8xLmZvcm1hdEVycm9yKShlcnIpLCBudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgcm93KTtcbiAgICAgICAgICAgIH0sIChlcnIsIGNvdW50KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KCgwLCBmb3JtYXRfZXJyb3JfMS5mb3JtYXRFcnJvcikoZXJyKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc29sdmUoY291bnQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuU3RhdGVtZW50ID0gU3RhdGVtZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3RhdGVtZW50LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sqlite/build/Statement.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sqlite/build/index.mjs":
/*!*********************************************!*\
  !*** ./node_modules/sqlite/build/index.mjs ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Database: () => (/* reexport safe */ _Database_js__WEBPACK_IMPORTED_MODULE_1__.Database),\n/* harmony export */   Statement: () => (/* reexport safe */ _Statement_js__WEBPACK_IMPORTED_MODULE_0__.Statement),\n/* harmony export */   __esModule: () => (/* reexport safe */ _Statement_js__WEBPACK_IMPORTED_MODULE_0__.__esModule),\n/* harmony export */   open: () => (/* binding */ open)\n/* harmony export */ });\n/* harmony import */ var _Statement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Statement.js */ \"(rsc)/./node_modules/sqlite/build/Statement.js\");\n/* harmony import */ var _Database_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Database.js */ \"(rsc)/./node_modules/sqlite/build/Database.js\");\n\n\n\n\n/**\n * Opens a database for manipulation. Most users will call this to get started.\n */\nasync function open(config) {\n  const db = new _Database_js__WEBPACK_IMPORTED_MODULE_1__.Database(config);\n  await db.open();\n  return db;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc3FsaXRlL2J1aWxkL2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBK0I7QUFDRDtBQUNPOztBQUVyQztBQUNBO0FBQ0E7QUFDTztBQUNQLGlCQUFpQixrREFBaUI7QUFDbEM7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEltYW5nXFxEb2N1bWVudHNcXEdpdEh1Ylxcc2VsZi1jbGFpbS1saW5rXFxub2RlX21vZHVsZXNcXHNxbGl0ZVxcYnVpbGRcXGluZGV4Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgKiBmcm9tIFwiLi9TdGF0ZW1lbnQuanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL0RhdGFiYXNlLmpzXCI7XG5pbXBvcnQgRGF0YWJhc2UgZnJvbSBcIi4vRGF0YWJhc2UuanNcIjtcblxuLyoqXG4gKiBPcGVucyBhIGRhdGFiYXNlIGZvciBtYW5pcHVsYXRpb24uIE1vc3QgdXNlcnMgd2lsbCBjYWxsIHRoaXMgdG8gZ2V0IHN0YXJ0ZWQuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBvcGVuKGNvbmZpZykge1xuICBjb25zdCBkYiA9IG5ldyBEYXRhYmFzZS5EYXRhYmFzZShjb25maWcpO1xuICBhd2FpdCBkYi5vcGVuKCk7XG4gIHJldHVybiBkYjtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sqlite/build/index.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/sqlite/build/utils/format-error.js":
/*!*********************************************************!*\
  !*** ./node_modules/sqlite/build/utils/format-error.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.formatError = void 0;\nfunction formatError(err) {\n    if (err instanceof Error) {\n        return err;\n    }\n    if (typeof err === 'object') {\n        const newError = new Error();\n        for (let prop in err) {\n            newError[prop] = err[prop];\n        }\n        // message isn't part of the enumerable set\n        if (err.message) {\n            newError.message = err.message;\n        }\n        return newError;\n    }\n    if (typeof err === 'string') {\n        return new Error(err);\n    }\n    return new Error(err);\n}\nexports.formatError = formatError;\n//# sourceMappingURL=format-error.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc3FsaXRlL2J1aWxkL3V0aWxzL2Zvcm1hdC1lcnJvci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxJbWFuZ1xcRG9jdW1lbnRzXFxHaXRIdWJcXHNlbGYtY2xhaW0tbGlua1xcbm9kZV9tb2R1bGVzXFxzcWxpdGVcXGJ1aWxkXFx1dGlsc1xcZm9ybWF0LWVycm9yLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5mb3JtYXRFcnJvciA9IHZvaWQgMDtcbmZ1bmN0aW9uIGZvcm1hdEVycm9yKGVycikge1xuICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICByZXR1cm4gZXJyO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGVyciA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgY29uc3QgbmV3RXJyb3IgPSBuZXcgRXJyb3IoKTtcbiAgICAgICAgZm9yIChsZXQgcHJvcCBpbiBlcnIpIHtcbiAgICAgICAgICAgIG5ld0Vycm9yW3Byb3BdID0gZXJyW3Byb3BdO1xuICAgICAgICB9XG4gICAgICAgIC8vIG1lc3NhZ2UgaXNuJ3QgcGFydCBvZiB0aGUgZW51bWVyYWJsZSBzZXRcbiAgICAgICAgaWYgKGVyci5tZXNzYWdlKSB7XG4gICAgICAgICAgICBuZXdFcnJvci5tZXNzYWdlID0gZXJyLm1lc3NhZ2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld0Vycm9yO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGVyciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihlcnIpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEVycm9yKGVycik7XG59XG5leHBvcnRzLmZvcm1hdEVycm9yID0gZm9ybWF0RXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb3JtYXQtZXJyb3IuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sqlite/build/utils/format-error.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sqlite/build/utils/migrate.js":
/*!****************************************************!*\
  !*** ./node_modules/sqlite/build/utils/migrate.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.migrate = exports.readMigrations = void 0;\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst path = __webpack_require__(/*! path */ \"path\");\nasync function readMigrations(migrationPath) {\n    const migrationsPath = migrationPath || path.join(process.cwd(), 'migrations');\n    const location = path.resolve(migrationsPath);\n    // Get the list of migration files, for example:\n    //   { id: 1, name: 'initial', filename: '001-initial.sql' }\n    //   { id: 2, name: 'feature', filename: '002-feature.sql' }\n    const migrationFiles = await new Promise((resolve, reject) => {\n        fs.readdir(location, (err, files) => {\n            if (err) {\n                return reject(err);\n            }\n            resolve(files\n                .map(x => x.match(/^(\\d+).(.*?)\\.sql$/))\n                .filter(x => x !== null)\n                .map(x => ({ id: Number(x[1]), name: x[2], filename: x[0] }))\n                .sort((a, b) => Math.sign(a.id - b.id)));\n        });\n    });\n    if (!migrationFiles.length) {\n        throw new Error(`No migration files found in '${location}'.`);\n    }\n    // Get the list of migrations, for example:\n    //   { id: 1, name: 'initial', filename: '001-initial.sql', up: ..., down: ... }\n    //   { id: 2, name: 'feature', filename: '002-feature.sql', up: ..., down: ... }\n    return Promise.all(migrationFiles.map(migration => new Promise((resolve, reject) => {\n        const filename = path.join(location, migration.filename);\n        fs.readFile(filename, 'utf-8', (err, data) => {\n            if (err) {\n                return reject(err);\n            }\n            const [up, down] = data.split(/^--\\s+?down\\b/im);\n            const migrationData = migration;\n            migrationData.up = up.replace(/^-- .*?$/gm, '').trim(); // Remove comments\n            migrationData.down = down ? down.trim() : ''; // and trim whitespaces\n            resolve(migrationData);\n        });\n    })));\n}\nexports.readMigrations = readMigrations;\n/**\n * Migrates database schema to the latest version\n */\nasync function migrate(db, config = {}) {\n    config.force = config.force || false;\n    config.table = config.table || 'migrations';\n    const { force, table } = config;\n    const migrations = config.migrations\n        ? config.migrations\n        : await readMigrations(config.migrationsPath);\n    // Create a database table for migrations meta data if it doesn't exist\n    await db.run(`CREATE TABLE IF NOT EXISTS \"${table}\" (\n  id   INTEGER PRIMARY KEY,\n  name TEXT    NOT NULL,\n  up   TEXT    NOT NULL,\n  down TEXT    NOT NULL\n)`);\n    // Get the list of already applied migrations\n    let dbMigrations = await db.all(`SELECT id, name, up, down FROM \"${table}\" ORDER BY id ASC`);\n    // Undo migrations that exist only in the database but not in files,\n    // also undo the last migration if the `force` option is enabled.\n    const lastMigration = migrations[migrations.length - 1];\n    for (const migration of dbMigrations\n        .slice()\n        .sort((a, b) => Math.sign(b.id - a.id))) {\n        if (!migrations.some(x => x.id === migration.id) ||\n            (force && migration.id === lastMigration.id)) {\n            await db.run('BEGIN');\n            try {\n                await db.exec(migration.down);\n                await db.run(`DELETE FROM \"${table}\" WHERE id = ?`, migration.id);\n                await db.run('COMMIT');\n                dbMigrations = dbMigrations.filter(x => x.id !== migration.id);\n            }\n            catch (err) {\n                await db.run('ROLLBACK');\n                throw err;\n            }\n        }\n        else {\n            break;\n        }\n    }\n    // Apply pending migrations\n    const lastMigrationId = dbMigrations.length\n        ? dbMigrations[dbMigrations.length - 1].id\n        : 0;\n    for (const migration of migrations) {\n        if (migration.id > lastMigrationId) {\n            await db.run('BEGIN');\n            try {\n                await db.exec(migration.up);\n                await db.run(`INSERT INTO \"${table}\" (id, name, up, down) VALUES (?, ?, ?, ?)`, migration.id, migration.name, migration.up, migration.down);\n                await db.run('COMMIT');\n            }\n            catch (err) {\n                await db.run('ROLLBACK');\n                throw err;\n            }\n        }\n    }\n}\nexports.migrate = migrate;\n//# sourceMappingURL=migrate.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc3FsaXRlL2J1aWxkL3V0aWxzL21pZ3JhdGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZUFBZSxHQUFHLHNCQUFzQjtBQUN4QyxXQUFXLG1CQUFPLENBQUMsY0FBSTtBQUN2QixhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsOENBQThDO0FBQzNFO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBLHdEQUF3RCxTQUFTO0FBQ2pFO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEUsMERBQTBEO0FBQzFEO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBLFlBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxNQUFNO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxNQUFNO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsTUFBTTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsTUFBTTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcSW1hbmdcXERvY3VtZW50c1xcR2l0SHViXFxzZWxmLWNsYWltLWxpbmtcXG5vZGVfbW9kdWxlc1xcc3FsaXRlXFxidWlsZFxcdXRpbHNcXG1pZ3JhdGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm1pZ3JhdGUgPSBleHBvcnRzLnJlYWRNaWdyYXRpb25zID0gdm9pZCAwO1xuY29uc3QgZnMgPSByZXF1aXJlKFwiZnNcIik7XG5jb25zdCBwYXRoID0gcmVxdWlyZShcInBhdGhcIik7XG5hc3luYyBmdW5jdGlvbiByZWFkTWlncmF0aW9ucyhtaWdyYXRpb25QYXRoKSB7XG4gICAgY29uc3QgbWlncmF0aW9uc1BhdGggPSBtaWdyYXRpb25QYXRoIHx8IHBhdGguam9pbihwcm9jZXNzLmN3ZCgpLCAnbWlncmF0aW9ucycpO1xuICAgIGNvbnN0IGxvY2F0aW9uID0gcGF0aC5yZXNvbHZlKG1pZ3JhdGlvbnNQYXRoKTtcbiAgICAvLyBHZXQgdGhlIGxpc3Qgb2YgbWlncmF0aW9uIGZpbGVzLCBmb3IgZXhhbXBsZTpcbiAgICAvLyAgIHsgaWQ6IDEsIG5hbWU6ICdpbml0aWFsJywgZmlsZW5hbWU6ICcwMDEtaW5pdGlhbC5zcWwnIH1cbiAgICAvLyAgIHsgaWQ6IDIsIG5hbWU6ICdmZWF0dXJlJywgZmlsZW5hbWU6ICcwMDItZmVhdHVyZS5zcWwnIH1cbiAgICBjb25zdCBtaWdyYXRpb25GaWxlcyA9IGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgZnMucmVhZGRpcihsb2NhdGlvbiwgKGVyciwgZmlsZXMpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNvbHZlKGZpbGVzXG4gICAgICAgICAgICAgICAgLm1hcCh4ID0+IHgubWF0Y2goL14oXFxkKykuKC4qPylcXC5zcWwkLykpXG4gICAgICAgICAgICAgICAgLmZpbHRlcih4ID0+IHggIT09IG51bGwpXG4gICAgICAgICAgICAgICAgLm1hcCh4ID0+ICh7IGlkOiBOdW1iZXIoeFsxXSksIG5hbWU6IHhbMl0sIGZpbGVuYW1lOiB4WzBdIH0pKVxuICAgICAgICAgICAgICAgIC5zb3J0KChhLCBiKSA9PiBNYXRoLnNpZ24oYS5pZCAtIGIuaWQpKSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIGlmICghbWlncmF0aW9uRmlsZXMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gbWlncmF0aW9uIGZpbGVzIGZvdW5kIGluICcke2xvY2F0aW9ufScuYCk7XG4gICAgfVxuICAgIC8vIEdldCB0aGUgbGlzdCBvZiBtaWdyYXRpb25zLCBmb3IgZXhhbXBsZTpcbiAgICAvLyAgIHsgaWQ6IDEsIG5hbWU6ICdpbml0aWFsJywgZmlsZW5hbWU6ICcwMDEtaW5pdGlhbC5zcWwnLCB1cDogLi4uLCBkb3duOiAuLi4gfVxuICAgIC8vICAgeyBpZDogMiwgbmFtZTogJ2ZlYXR1cmUnLCBmaWxlbmFtZTogJzAwMi1mZWF0dXJlLnNxbCcsIHVwOiAuLi4sIGRvd246IC4uLiB9XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKG1pZ3JhdGlvbkZpbGVzLm1hcChtaWdyYXRpb24gPT4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCBmaWxlbmFtZSA9IHBhdGguam9pbihsb2NhdGlvbiwgbWlncmF0aW9uLmZpbGVuYW1lKTtcbiAgICAgICAgZnMucmVhZEZpbGUoZmlsZW5hbWUsICd1dGYtOCcsIChlcnIsIGRhdGEpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBbdXAsIGRvd25dID0gZGF0YS5zcGxpdCgvXi0tXFxzKz9kb3duXFxiL2ltKTtcbiAgICAgICAgICAgIGNvbnN0IG1pZ3JhdGlvbkRhdGEgPSBtaWdyYXRpb247XG4gICAgICAgICAgICBtaWdyYXRpb25EYXRhLnVwID0gdXAucmVwbGFjZSgvXi0tIC4qPyQvZ20sICcnKS50cmltKCk7IC8vIFJlbW92ZSBjb21tZW50c1xuICAgICAgICAgICAgbWlncmF0aW9uRGF0YS5kb3duID0gZG93biA/IGRvd24udHJpbSgpIDogJyc7IC8vIGFuZCB0cmltIHdoaXRlc3BhY2VzXG4gICAgICAgICAgICByZXNvbHZlKG1pZ3JhdGlvbkRhdGEpO1xuICAgICAgICB9KTtcbiAgICB9KSkpO1xufVxuZXhwb3J0cy5yZWFkTWlncmF0aW9ucyA9IHJlYWRNaWdyYXRpb25zO1xuLyoqXG4gKiBNaWdyYXRlcyBkYXRhYmFzZSBzY2hlbWEgdG8gdGhlIGxhdGVzdCB2ZXJzaW9uXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIG1pZ3JhdGUoZGIsIGNvbmZpZyA9IHt9KSB7XG4gICAgY29uZmlnLmZvcmNlID0gY29uZmlnLmZvcmNlIHx8IGZhbHNlO1xuICAgIGNvbmZpZy50YWJsZSA9IGNvbmZpZy50YWJsZSB8fCAnbWlncmF0aW9ucyc7XG4gICAgY29uc3QgeyBmb3JjZSwgdGFibGUgfSA9IGNvbmZpZztcbiAgICBjb25zdCBtaWdyYXRpb25zID0gY29uZmlnLm1pZ3JhdGlvbnNcbiAgICAgICAgPyBjb25maWcubWlncmF0aW9uc1xuICAgICAgICA6IGF3YWl0IHJlYWRNaWdyYXRpb25zKGNvbmZpZy5taWdyYXRpb25zUGF0aCk7XG4gICAgLy8gQ3JlYXRlIGEgZGF0YWJhc2UgdGFibGUgZm9yIG1pZ3JhdGlvbnMgbWV0YSBkYXRhIGlmIGl0IGRvZXNuJ3QgZXhpc3RcbiAgICBhd2FpdCBkYi5ydW4oYENSRUFURSBUQUJMRSBJRiBOT1QgRVhJU1RTIFwiJHt0YWJsZX1cIiAoXG4gIGlkICAgSU5URUdFUiBQUklNQVJZIEtFWSxcbiAgbmFtZSBURVhUICAgIE5PVCBOVUxMLFxuICB1cCAgIFRFWFQgICAgTk9UIE5VTEwsXG4gIGRvd24gVEVYVCAgICBOT1QgTlVMTFxuKWApO1xuICAgIC8vIEdldCB0aGUgbGlzdCBvZiBhbHJlYWR5IGFwcGxpZWQgbWlncmF0aW9uc1xuICAgIGxldCBkYk1pZ3JhdGlvbnMgPSBhd2FpdCBkYi5hbGwoYFNFTEVDVCBpZCwgbmFtZSwgdXAsIGRvd24gRlJPTSBcIiR7dGFibGV9XCIgT1JERVIgQlkgaWQgQVNDYCk7XG4gICAgLy8gVW5kbyBtaWdyYXRpb25zIHRoYXQgZXhpc3Qgb25seSBpbiB0aGUgZGF0YWJhc2UgYnV0IG5vdCBpbiBmaWxlcyxcbiAgICAvLyBhbHNvIHVuZG8gdGhlIGxhc3QgbWlncmF0aW9uIGlmIHRoZSBgZm9yY2VgIG9wdGlvbiBpcyBlbmFibGVkLlxuICAgIGNvbnN0IGxhc3RNaWdyYXRpb24gPSBtaWdyYXRpb25zW21pZ3JhdGlvbnMubGVuZ3RoIC0gMV07XG4gICAgZm9yIChjb25zdCBtaWdyYXRpb24gb2YgZGJNaWdyYXRpb25zXG4gICAgICAgIC5zbGljZSgpXG4gICAgICAgIC5zb3J0KChhLCBiKSA9PiBNYXRoLnNpZ24oYi5pZCAtIGEuaWQpKSkge1xuICAgICAgICBpZiAoIW1pZ3JhdGlvbnMuc29tZSh4ID0+IHguaWQgPT09IG1pZ3JhdGlvbi5pZCkgfHxcbiAgICAgICAgICAgIChmb3JjZSAmJiBtaWdyYXRpb24uaWQgPT09IGxhc3RNaWdyYXRpb24uaWQpKSB7XG4gICAgICAgICAgICBhd2FpdCBkYi5ydW4oJ0JFR0lOJyk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IGRiLmV4ZWMobWlncmF0aW9uLmRvd24pO1xuICAgICAgICAgICAgICAgIGF3YWl0IGRiLnJ1bihgREVMRVRFIEZST00gXCIke3RhYmxlfVwiIFdIRVJFIGlkID0gP2AsIG1pZ3JhdGlvbi5pZCk7XG4gICAgICAgICAgICAgICAgYXdhaXQgZGIucnVuKCdDT01NSVQnKTtcbiAgICAgICAgICAgICAgICBkYk1pZ3JhdGlvbnMgPSBkYk1pZ3JhdGlvbnMuZmlsdGVyKHggPT4geC5pZCAhPT0gbWlncmF0aW9uLmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBkYi5ydW4oJ1JPTExCQUNLJyk7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQXBwbHkgcGVuZGluZyBtaWdyYXRpb25zXG4gICAgY29uc3QgbGFzdE1pZ3JhdGlvbklkID0gZGJNaWdyYXRpb25zLmxlbmd0aFxuICAgICAgICA/IGRiTWlncmF0aW9uc1tkYk1pZ3JhdGlvbnMubGVuZ3RoIC0gMV0uaWRcbiAgICAgICAgOiAwO1xuICAgIGZvciAoY29uc3QgbWlncmF0aW9uIG9mIG1pZ3JhdGlvbnMpIHtcbiAgICAgICAgaWYgKG1pZ3JhdGlvbi5pZCA+IGxhc3RNaWdyYXRpb25JZCkge1xuICAgICAgICAgICAgYXdhaXQgZGIucnVuKCdCRUdJTicpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhd2FpdCBkYi5leGVjKG1pZ3JhdGlvbi51cCk7XG4gICAgICAgICAgICAgICAgYXdhaXQgZGIucnVuKGBJTlNFUlQgSU5UTyBcIiR7dGFibGV9XCIgKGlkLCBuYW1lLCB1cCwgZG93bikgVkFMVUVTICg/LCA/LCA/LCA/KWAsIG1pZ3JhdGlvbi5pZCwgbWlncmF0aW9uLm5hbWUsIG1pZ3JhdGlvbi51cCwgbWlncmF0aW9uLmRvd24pO1xuICAgICAgICAgICAgICAgIGF3YWl0IGRiLnJ1bignQ09NTUlUJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgZGIucnVuKCdST0xMQkFDSycpO1xuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMubWlncmF0ZSA9IG1pZ3JhdGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1taWdyYXRlLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sqlite/build/utils/migrate.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sqlite/build/utils/strings.js":
/*!****************************************************!*\
  !*** ./node_modules/sqlite/build/utils/strings.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.toSqlParams = void 0;\n/**\n * Allows for using strings and `sql-template-strings`. Converts both to a\n * format that's usable by the SQL methods\n *\n * @param sql A SQL string or `sql-template-strings` object\n * @param params An array of parameters\n */\nfunction toSqlParams(sql, params = []) {\n    if (typeof sql === 'string') {\n        return {\n            sql,\n            params\n        };\n    }\n    return {\n        sql: sql.sql,\n        params: sql.values\n    };\n}\nexports.toSqlParams = toSqlParams;\n//# sourceMappingURL=strings.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc3FsaXRlL2J1aWxkL3V0aWxzL3N0cmluZ3MuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEltYW5nXFxEb2N1bWVudHNcXEdpdEh1Ylxcc2VsZi1jbGFpbS1saW5rXFxub2RlX21vZHVsZXNcXHNxbGl0ZVxcYnVpbGRcXHV0aWxzXFxzdHJpbmdzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy50b1NxbFBhcmFtcyA9IHZvaWQgMDtcbi8qKlxuICogQWxsb3dzIGZvciB1c2luZyBzdHJpbmdzIGFuZCBgc3FsLXRlbXBsYXRlLXN0cmluZ3NgLiBDb252ZXJ0cyBib3RoIHRvIGFcbiAqIGZvcm1hdCB0aGF0J3MgdXNhYmxlIGJ5IHRoZSBTUUwgbWV0aG9kc1xuICpcbiAqIEBwYXJhbSBzcWwgQSBTUUwgc3RyaW5nIG9yIGBzcWwtdGVtcGxhdGUtc3RyaW5nc2Agb2JqZWN0XG4gKiBAcGFyYW0gcGFyYW1zIEFuIGFycmF5IG9mIHBhcmFtZXRlcnNcbiAqL1xuZnVuY3Rpb24gdG9TcWxQYXJhbXMoc3FsLCBwYXJhbXMgPSBbXSkge1xuICAgIGlmICh0eXBlb2Ygc3FsID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3FsLFxuICAgICAgICAgICAgcGFyYW1zXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHNxbDogc3FsLnNxbCxcbiAgICAgICAgcGFyYW1zOiBzcWwudmFsdWVzXG4gICAgfTtcbn1cbmV4cG9ydHMudG9TcWxQYXJhbXMgPSB0b1NxbFBhcmFtcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0cmluZ3MuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sqlite/build/utils/strings.js\n");

/***/ })

};
;